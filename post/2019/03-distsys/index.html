<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.6.3">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Alexander Salimonov">

  
  
  
    
  
  <meta name="description" content=" ">

  
  <link rel="alternate" hreflang="en-us" href="/post/2019/03-distsys/">

  


  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    

    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.css">

  




  


  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon-32.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/post/2019/03-distsys/">

  
  
  
  
    
  
  
  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@asalimonov">
  <meta property="twitter:creator" content="@asalimonov">
  
  <meta property="og:site_name" content="Alexander Salimonov">
  <meta property="og:url" content="/post/2019/03-distsys/">
  <meta property="og:title" content="Высокая доступность: концепции, общие практики построения и сопровождения | Alexander Salimonov">
  <meta property="og:description" content=" "><meta property="og:image" content="/img/avatar_salimonov_small.jpeg">
  <meta property="twitter:image" content="/img/avatar_salimonov_small.jpeg"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2019-01-14T00:00:00&#43;00:00">
    
    <meta property="article:modified_time" content="2019-01-14T00:00:00&#43;00:00">
  

  


    






  






<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/2019/03-distsys/"
  },
  "headline": "Высокая доступность: концепции, общие практики построения и сопровождения",
  
  "datePublished": "2019-01-14T00:00:00Z",
  "dateModified": "2019-01-14T00:00:00Z",
  
  "author": {
    "@type": "Person",
    "name": "Alexander Salimonov"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "Alexander Salimonov",
    "logo": {
      "@type": "ImageObject",
      "url": "/img/icon-512.png"
    }
  },
  "description": " "
}
</script>

  

  


  


  





  <title>Высокая доступность: концепции, общие практики построения и сопровождения | Alexander Salimonov</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  

<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Alexander Salimonov</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Alexander Salimonov</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Home</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#projects"><span>Projects</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contact</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      <li class="nav-item">
        <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
      </li>
      

      

    </ul>

  </div>
</nav>


  <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>Высокая доступность: концепции, общие практики построения и сопровождения</h1>

  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    2019-01-14
  </span>
  

  

  

  
  
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/categories/high-availbility/">High availbility</a>, <a href="/categories/sdl/">SDL</a></span>
  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style">
      <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_Концепции">Концепции</a>
<ul class="sectlevel2">
<li><a href="#_Основы">Основы</a></li>
<li><a href="#_cap_теорема">CAP теорема</a></li>
<li><a href="#_Модели_консистентности">Модели консистентности</a></li>
<li><a href="#_acid">ACID</a></li>
<li><a href="#_base">BASE</a></li>
<li><a href="#_pacelc">PACELC</a></li>
<li><a href="#_conways_law">Conway&#8217;s law</a></li>
</ul>
</li>
<li><a href="#_Избыточность">Избыточность</a>
<ul class="sectlevel2">
<li><a href="#_Толерантность_к_отказам_fault_tolerance">Толерантность к отказам (fault tolerance)</a></li>
<li><a href="#_active_active">Active-Active</a></li>
<li><a href="#_multi_master">Multi-Master</a></li>
<li><a href="#_master_replica">Master-Replica</a></li>
<li><a href="#_Аварийное_переключение_failover_стратегии_и_практики">Аварийное переключение (failover), стратегии и практики</a></li>
<li><a href="#_Управление_отказами">Управление отказами</a></li>
</ul>
</li>
<li><a href="#_sla_slo_sli">SLA, SLO, SLI</a></li>
<li><a href="#_Организационные_подходы_для_построения_систем_высокой_доступности">Организационные подходы для построения систем высокой доступности</a>
<ul class="sectlevel2">
<li><a href="#_Не_экономить_на_самом_дешевом_железе">Не экономить на самом дешевом железе</a></li>
<li><a href="#_Согласованность">Согласованность</a></li>
<li><a href="#_Ответственность">Ответственность</a></li>
<li><a href="#_Устранение_единых_точек_отказа_single_point_of_failure_spof">Устранение единых точек отказа (Single Point of Failure (SPOF))</a></li>
<li><a href="#_Консолидация_серверов">Консолидация серверов</a></li>
<li><a href="#_Автоматизация_и_оптимизиация">Автоматизация и оптимизиация</a></li>
<li><a href="#_Типовые_конфигурации_и_общие_репозитории">Типовые конфигурации и общие репозитории</a></li>
<li><a href="#_Мониторинг_и_оповещение">Мониторинг и оповещение</a></li>
<li><a href="#_Измерение_производительности">Измерение производительности</a></li>
<li><a href="#_Обучение_и_тренинги_персонала">Обучение и тренинги персонала</a></li>
<li><a href="#_Раздельные_контуры">Раздельные контуры</a></li>
</ul>
</li>
<li><a href="#_Заключение">Заключение</a></li>
<li><a href="#_Ссылки">Ссылки</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="_Концепции">Концепции</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В прошлых статьях рассмотрели причины сбоев, типичный таймлайн сбоев, какие фазы там есть и какие действия обычно требуются, чтобы вернуть систему в стабильное рабочее состояние. Настало время погружаться в теорию HA глубже, но попытаться не распыляться на конкретные компоненты и решения, чтобы сохранить универсальность и иметь возможность применять их безотносительно частных случаев и реализаций.</p>
</div>
<div class="paragraph">
<p>Так, проектируя HA систему, прежде всего преследуют цель построить систему, которая бы за минимальные деньги держала определенную нагрузку и лишний раз не беспокоила (что в принципе тоже деньги). Соответственно, система должна быть:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Надежной:</strong> минимальный потенциал для сбоев.</p>
</li>
<li>
<p><strong>Избыточной:</strong> использовать имеющиеся ресурсы, чтобы продолжать работать даже после сбоя без внешнего вмешательства.</p>
</li>
<li>
<p><strong>Простой в управлении:</strong> все рабочие процессы, связанные с ней, понятны, зоны ответственности определены, на оперативные действия тратится минимум времени и усилий.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>И уже тут начинаются противоречия. Чем меньше компонентов в системе и их связанность - тем она надежней, при увеличении избыточности увеличивается и связанность, а количество сбоев в системе растет. Почему так? Рассмотрим в последующей статье - "Высокая доступность: надёжность компонентов и систем".</p>
</div>
<div class="paragraph">
<p>Управление распределенной системой сопряжено с её же сложностью, которую хотя бы отчасти удаётся скрыть под абстракциями систем управления конфигурациями, возможностями управлять группами развернутых сервисов, оркестрацией кластеров, формированием виртуальных сетей и даже клаудов.</p>
</div>
<div class="paragraph">
<p>В предыдущей статье был приведён пример расчёта влияния увеличения доступности на выручку, получаемую организацией. В подходах обеспечения HA для системы, либо её части, следует поступать аналогичным образом, то есть доставлять доступность как новую функцию с некоторой ценностью для бизнеса, с возможностью посчитать её ROI. Тем самым доступность системы будет находиться в соответствии с потребностями бизнеса, его планами и возможностями. А обоснование работ, критерии достижимости и средства, будут понятны и для владельцев продукта, и для исполнителей.</p>
</div>
<div class="paragraph">
<p>Упрощенная схема влияния доступности на выручку:<br>
<span class="image"><img src="./images/impact_of_availability.png" alt="Влияние доступности на выручку и затраты"></span></p>
</div>
<div class="paragraph">
<p>При такой простой мотивации поступают так же просто:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>анализируется текущий дизайн системы на возможные отказы;</p>
</li>
<li>
<p>составляется список сценариев отказа;</p>
</li>
<li>
<p>для каждого сценария указывается вероятность отказа и урон, им созданный;</p>
</li>
<li>
<p>важные сценарии для бизнеса фиксируются в требованиях;</p>
</li>
<li>
<p>проектирование решений по преодолению этих сценариев, оценивается стоимость реализации;</p>
</li>
<li>
<p>ревью решений, проверка гипотез по преодолению отказов;</p>
</li>
<li>
<p>реализация.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Потребность в высокой доступности может быть вызвана не только увеличением прибыли и уменьшения рисков, но и для соответствия определенным отраслевым и государственным стандартам и регламентам.</p>
</div>
<div class="sect2">
<h3 id="_Основы">Основы</h3>
<div class="paragraph">
<p>Отказоустойчивые системы, а значит системы с некоторой избыточностью, также являются подгруппой распределенных систем. При работе с ними инженеры иногда забывают о фундаментальных ограничениях или по привычке используют упрощенные модели, L. Peter Deutsh сформировал список из таких <strong>заблуждений</strong> в распределенных вычислениях:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Сеть надёжна.</p>
</li>
<li>
<p>Задержка (latency) сети равна нулю.</p>
</li>
<li>
<p>Пропускная способность бесконечна.</p>
</li>
<li>
<p>Сеть безопасна.</p>
</li>
<li>
<p>Топология не меняется.</p>
</li>
<li>
<p>Только один администратор.</p>
</li>
<li>
<p>Затраты времени на передачу равны нулю.</p>
</li>
<li>
<p>Сеть гомогенная.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Дополнение и объяснение этих заблуждений будет выходить за рамки данной статьи, но Вы сможете найти больше информации в публикации <a href="http://www.rgoarchitects.com/Files/fallacies.pdf">Fallacies of Distributed Computing: Explained</a> от архитектора Arnon Rotem-Gal-Oz.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cap_теорема">CAP теорема</h3>
<div class="paragraph">
<p>В этих заблуждениях упомянули, что задержка по сети не равна нулю, что пропускная способность не бесконечна, что сама сеть не надёжна. В следствии того, что информация не может распространяться по разным узлам сети мгновенно и в любом объеме, спровоцировано появление большого количества моделей управления данными в распределенных системах, а на основе них появилась CAP теорема <a href="#cap">[cap]</a>. Поверхностные детали теоремы рассматривать не будем, так как они интуитивно простые, прочтения статьи с Wikipedia достаточно. Сложность как обычно в деталях, а именно <strong>моделях консистентности</strong>, которые будут влиять на такие характеристики системы как: латентность, пропускная способность, величину RPO, способ решения проблем конкурентности.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Модели_консистентности">Модели консистентности</h3>
<div class="paragraph">
<p>Существует довольно большое множество моделей консистентности, которые описывают различные подходы при работе с данными в распределенной системе и естественно с больше, чем одним агентом, которые с ними работают. Так как статья посвящена высокодоступным системам, то мы подразумеваем, что клиенты получают доступ к сервису без ожиданий и попыток синхронизироваться друг с другом, то есть система работоспособна даже тогда, когда доступен остался лишь один узел. Это называется <code>wait-free</code>-атрибут распределенной системы. В следствии наличия wait-free атрибута, приходится раскрывать сам факт конкурентности доступа к данным в такой системе. Так как бизнес диктует свои потребности с некоторой областью возможностей, то при проектировании системы и мы можем выбирать, в каких случаях и как организовать проведение транзакций. Транзакций не в терминах СУБД, а в терминах предметной области, что важно.</p>
</div>
<div class="paragraph">
<p>Так выбираем между абсолютно строгим подходом доступа к данным и состоянием постоянной неконсистентности на узлах. Более формально: самый строгий способ достижения консистентности - использовать лишь один объект с данными и организовывать последовательный доступ к нему, если клиентов больше одного, то ни о каком wait-free там речи быть не может. Ослаблять требования этого способа можем через смягчающий критерий - раскрытие деталей конкурентной работы с данными, тем самым выстраивая правила (протокол) работы с ними, не допуская случаи появления неконсистентности в данных. Под протоколом подразумевается нахождение консенсуса для линеаризации проводимых транзакций.</p>
</div>
<div class="paragraph">
<p>Ниже представлена решетка моделей консистентности от самого слабого критерия до сильного. Граф разделён CAP границей, всё что ниже неё может использоваться в wait-free системах, всё что выше - нет.</p>
</div>
<div class="paragraph">
<p>Решётка моделей консистентности<a href="#ds1e">[ds1e]</a>:
<span class="image"><img src="./images/consistancy_lattice.png" alt="Решетка консистентности"></span>
Как видно из изображения, в wait-free системе могу быть реализованы: update consistency модель, eventual concistency, pipelined consistency.<br>
Отдельно хочется отметить serilizability, многие инженеры ошибочно считают, что она даст возможность забыть о проблеме консистентности проведения транзакций в распределённой системе. Она строже event consistency, но всё же не исключает проблем при разделении кластера (<a href="https://en.wikipedia.org/wiki/Split-brain_(computing)">split brain</a>), так как гарантирует проведение изолированных серий транзакций на локальных данных, а синхронизацию через shared object и арбитраж. Когда отделившийся узел возвращается в кластер, он будет вынужден вернуться к состоянию в момент сплита, либо потребует операцию по слиянию данных. Такая модель позволяет реализовать хорошие показатели производительности и предоставляет отличный контроль данных. Именно поэтому получила столь широкое распространение и для работы с важными данными (мед. записи, банковские транзакции), но как всегда есть нюансы.</p>
</div>
<div class="paragraph">
<p>Сверху находятся модели с жесткими критериями последовательности транзакций и линеаризацией, получается не wait-free система, но данные однозначно останутся консистентными в любой момент времени. Для более более подробного знакомства с этими моделями рекомендую заглянуть в <a href="#ds1e">[ds1e]</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_acid">ACID</h3>
<div class="paragraph">
<p>Большинство с ACID должны быть знакомы в общих чертах и даже в трактовках. Если нет - есть <a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">wiki: ACID_(computer_science)</a>. Продолжаем тему применимости принципов и моделей в построении HA систем. Ниже граф уровни изоляции транзакций (AC<strong>I</strong>D) на основе CAP моделей, источник <a href="#hat">[hat]</a>  (нарисовал <a href="https://twitter.com/0x0FFF/">Alexey Grischenko</a>):
<span class="image"><img src="./images/cap_map.jpeg" alt="CAP map"></span></p>
</div>
<div class="paragraph">
<p>Что это значит:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>граф - корень (Strong-1SR) - наивысший уровень "изоляции" транзакций (все транзакции последовательны), чем дальше от корня, тем ниже уровень изоляции транзакции, тем меньше нужно ресурсов на её проведение в распределённом приложении</p>
</li>
<li>
<p>красное - модель невозможно использовать в HA системе<br></p>
</li>
<li>
<p>зелёное - используется<br></p>
</li>
<li>
<p>синее - используется для тех случаев, когда клиент работает лишь с одним узлом, либо сам может выполнять роль сервера.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Практическое использование. В большинстве классических РСУБД по умолчанию используется serializable модель, иногда и как наиболее строгая, пример PostgreSQL <a href="#pgsql-tr">[pgsql-tr]</a>. Microsoft SQL Server <a href="#mssql-si">[mssql-si]</a>  и Oracle <a href="#oracle-si">[oracle-si]</a> позволяют повысить изоляцию до snapshot isolation.</p>
</div>
<div class="paragraph">
<p>В принципе, когда говорят про <strong>C</strong>AP и AC<strong>I</strong>D, зачастую подразумевают не serializable, а linearizable консистентность. Нюанс тут в том, что большинство РСУБД используют serializable или snapshot уровни изоляции с <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multivesion concurrency control (MVCC)</a>, но не способны реализовать линеаризуемость транзакций, так как это сильно снизит скорость конкурентного доступа к данным. В этом и есть неочевидный и мало кому знакомый нюанс использования этих терминов.</p>
</div>
<div class="paragraph">
<p>Те, кто уже хорошо знаком с ACID, могут обратить внимание, что сериализуемые транзакции, являющиеся "эталоном" для достижения целостности и истинности данных в принципе для большой распределенной системы, не подходят из-за жестких ограничений. При большом количестве узлов требует и больших затрат ресурсов, и времени, нет толерантности к разделению(CA<strong>P</strong>). Это и вызвало появление AP NoSQL систем таких как Amazon Dynamo, Cassandra.</p>
</div>
<div class="paragraph">
<p>Из-за вот таких неочевидных нюансов, невозможности отнести все системы к классу CA, AP, CP, потребности более точно и кратко описать системы использующие не serializable модель и появились <a href="#_base">BASE</a> и <a href="#_pacelc">PACELC</a> аббревиатуры.</p>
</div>
</div>
<div class="sect2">
<h3 id="_base">BASE</h3>
<div class="paragraph">
<p>Обязано появлением систем на основе eventual consistency, для которых приемлемо находиться в неконсистетном состоянии какое-то время и отдавать клиенту неконсистентные данные, тем самым сохраняя доступность.
BASE - <strong>B</strong>asically <strong>A</strong>vailable, <strong>S</strong>oft state, <strong>E</strong>ventual consistency. По графу моделей консистентности видно, что они не такие жесткие, как системы на serializable модели.
Пример BASE-баз данных: CouchDB, Amazon SimpleDB, Amazon Dynamo, Riak.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pacelc">PACELC</h3>
<div class="paragraph">
<p>Ещё одна post-CAP теорема, а фактически её расширение. Созданное, чтобы в общую модель добавить современные NoSQL решения. Была предложена в работе "Consistency Tradeoffs in Modern Distributed Database System Design" <a href="#abadi">[abadi]</a>. Трактовка из оригинала:</p>
</div>
<div id="pacelsabadi" class="quoteblock">
<blockquote>
<div class="paragraph">
<p>A more complete portrayal of the space of potential consistency tradeoffs for DDBSs can be achieved by rewriting CAP as PACELC (pronounced “pass-elk”): if there is a partition (<strong>P</strong>), how does the system trade off availability and consistency (<strong>A</strong> and <strong>C</strong>); else (<strong>E</strong>), when the system is running normally in the absence of partitions, how does the system
trade off latency (<strong>L</strong>) and consistency (<strong>C</strong>)?</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Daniel J. Abadi
</div>
</div>
<div class="paragraph">
<p>Теперь в рамках одной теоремы можно более точно указать "классы" хранилищ и описать требования к ним. Классические ACID системы - PC/EС. Сохраняют целостность кластера (P), консистетность (С), но вынуждены жертвовать доступностью и задержками ради (E) консистентности (С).
Современные NoSQL, в лице MongoDB, Amazon Dynamo, Cassandra, Aerospike являются PA/EL: уcтойчивы к сплитам (P), сохраняют доступность (A), но жертвуют консистентностью ради (E) низких задержек (L).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Выше приведены модели, используемые по умолчанию. Большинство современных СУБД поддерживают конфигурирование уровней коснистентности, которые могут зависеть от настроек сервера, базы, сессии. Обращайте на это внимание при работе с ними, а тем более при выборе СУБД.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Для более детальной информации, рекомендую всё же ознакомиться c <a href="#abadi">[abadi]</a> и заглянуть в <a href="https://en.wikipedia.org/wiki/PACELC_theorem">wikipedia</a>, где приводятся классы наиболее популярных СУБД.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conways_law">Conway&#8217;s law</h3>
<div class="paragraph">
<p>Отдельно хочется упомянуть Conway&#8217;s Law.</p>
</div>
<div id="conwayslaw" class="quoteblock">
<blockquote>
<div class="paragraph">
<p>organizations which design systems &#8230;&#8203; are constrained to produce designs which are copies of the communication structures of these organizations.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; M. Conway
</div>
</div>
<div class="paragraph">
<p>Строя распределённую систему, формируйте команды под задачи, а не наоборот. Иначе система будет иметь такие же проблемы, что и <a href="https://twitter.com/shanselman/status/790285272021803008">здесь</a>.</p>
</div>
<div class="paragraph">
<p>Существует множество других законов и следствий, которые прямым или косвенным образом связаны с распределенными и высокодоступными системами, но вместить их может, пожалуй, целая энциклопедия (например - <a href="https://www.springer.com/gp/book/9780387097657">Encyclopedia of Parallel Computing</a>), так что здесь ограничимся лишь самыми базовыми.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Избыточность">Избыточность</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Как ранее было описано, избыточность в системе позволяет продолжить работу после сбоя и даже без потери данных. Избыточность в компонентах системы может быть на разных уровнях, всё зависит от того, для какого сценария сбоя эти избыточные компоненты предназначены.
Примеры создания избыточности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>зеркалирование дисков - RAID <a href="#wiki_raid">[wiki_raid]</a> или <strong>Redundant</strong> Arrays of Independet Disks</p>
</li>
<li>
<p>резервные блоки питания серверов</p>
</li>
<li>
<p>дополнительные сетевые интерфейсы, коммутаторы</p>
</li>
<li>
<p>резервные линии электроснабжения, питание серверов через источники бесперебойного питания</p>
</li>
<li>
<p>избыточность в кластере сервисов, обычно он называется высокодоступным кластером или HA cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если блок компонентов содержит в себе избыточность и может без внешнего вмешательства переключаться на избыточный (резервный) элемент, который и возьмет на себя нагрузку. Такой компонент называется устойчивым к сбоям (fault-tolerant). Далее рассмотрим стратегии и прочие нюансы при переключении на избыточные элементы системы после сбоя, а также конфигурации отказоустойчивых кластеров.</p>
</div>
<div class="sect2">
<h3 id="_Толерантность_к_отказам_fault_tolerance">Толерантность к отказам (fault tolerance)</h3>
<div class="paragraph">
<p>Как ранее уже упоминалось, не все отказы можно обработать, поэтому фокусируются лишь на некоторых, ориентируясь на потребности. Ниже четыре самых главных подхода обработки отказа:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Masking tolerance - обработка отказа без существенных изменений клиента, агента или связанного компонента, используется в критически важных системах.</p>
</li>
<li>
<p>Nonmasking tolerance - сбой может временно повлиять на связанный компонент, но без эскалации сбоя выше него, как правило это видно по увеличению таймингов.</p>
</li>
<li>
<p>Fail-Safe - обработка отказа с прерыванием операции в безопасном для остальных состоянии. Самоликвидация ракет, мин, плавное торможение самоуправляемого автомобиля и есть fail-safe.</p>
</li>
<li>
<p>Graceful degradation - после сбоя система не может скрыть последствия сбоя, не может восстановиться, функционирует с ограничениями, сниженной производительностью. Пример: использование резервного канала с меньшей пропускной способностью и более высокими задержками, временное нарушение консистентности, которое можно считать приемлемым, недоступность части сервисов.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Если последствия отказа нельзя скрыть от клиента или зависимых компонентов (невозможно, слишком дорого, не критично), то нужно его хотя бы локализовать, переведя и функционирование зависимого компонента в ограниченный режим. Такая локализация поможет определить сбой в системе более точно, быстро, проще будет обработать.</p>
</div>
<div class="paragraph">
<p>Ниже рассмотрим самые популярные схемы организации избыточности кластеров для обработки отказов.</p>
</div>
</div>
<div class="sect2">
<h3 id="_active_active">Active-Active</h3>
<div class="paragraph">
<p>Один из самых популярных вариантов организации высокодоступных кластеров при построении Web-сервисов. Все узлы в активном использовании, балансировщик раскидывает трафик в зависимости от его политики (random, round robin, etc.). В случае, если один из узлов перестал отвечать, балансировщик сам может перекинуть коннект на другой узел, тем самым избежав потери данных и с нулевым даунтаймом.
Плюсы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>уменьшение даунтайма, так как фактический узел невидим для клиента</p>
</li>
<li>
<p>эффективное использование оборудования, реализация полной его ёмкости</p>
</li>
<li>
<p>легко наращивать нагрузку</p>
</li>
<li>
<p>тестирование аварийного переключения за балансировщиком менее рискованное</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Минусы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>организация такой архитектуры сопряжена с определенными трудностями или вообще невозможна в случае хранения состояния (сессии) на стороне сервера. Не всегда можно привязать юзеров к конкретному серверу за балансировщиком, failover также будет сопряжен с определенными проблемами.</p>
</li>
<li>
<p>возможны коллизии данных без роутинга клиентов на определенные узлы</p>
</li>
<li>
<p>следует крайне аккуратно рассчитывать запас по производительности в случае выхода из строя одного из узлов, производительность может упасть не линейно и вызвать отказ и второго узла.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Примеры: кластера WEB, REST серверов.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multi_master">Multi-Master</h3>
<div class="paragraph">
<p>Сходный принцип с Activ-Active, за тем исключением, что балансировщик обычно не используется, обычно клиент уже знает несколько адресов Master узлов, к которым и пробует подключаться. В случае невозможности подсоединиться к первому, пробует следующий адрес и т.д.
Встречается в двух основных случаях: процессинг большого количества данных (батчи, стримы), отказоустойчивые БД.</p>
</div>
<div class="paragraph">
<p>В случае процессинга мастер-узлы сами выполняют лишь координационную функцию, обмениваясь между собой метаданными и занимаясь скедулингом (Spark, Flink)</p>
</div>
<div class="paragraph">
<p>В базах данных: Cassandra, MySQL с Multi-Master, Aerospike, MSSQL c P2P transaction replication.</p>
</div>
<div class="sect3">
<h4 id="_cold_standby">Cold Standby</h4>
<div class="paragraph">
<p>Один активный компонент предоставляет нужные для системы функции. Когда случается его отказ, cold standby компонент переходит в режим hot и замещает предыдущий. В системе может быть более чем два компонента, тем самым повышая её живучесть. Её плюс в том, что в такой системе деградация очевидна и скорость отказов (failure reate) константна, что упрощает оценку и прогнозирование. Практически был вытеснен, остался в legacy c монолитами.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hot_standby">Hot Standby</h4>
<div class="paragraph">
<p>В этом случае standby компонент, который защищает основной, также включен. Данные на standby реплицируются с секундными интервалами. В случае отказа основного компонента, происходит переключение (failover) на второй, в случае успешного переключения downtime стремится или равен нулю. Но есть следующие нюансы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Из-за того, что они находятся под разной нагрузкой у них могут быть и разные скорости отказа.</p>
</li>
<li>
<p>Подразумевается, что механизм переключения абсолютно надёжен, если нет - система также подвергнется отказу</p>
</li>
<li>
<p>В случае отказа standby компонента система не затронута.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В качестве примера такой архитектуры можно привести: PostgreSQL, MySQL, MSSQL.
HDFS где инстансы используются NameNode в таком режиме. Также практикуется развертывание Cassandra кластеров в multizone-Region в AWS.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_master_replica">Master-Replica</h3>
<div class="paragraph">
<p>Вариация Hot Standby. Все узлы кластера проверяют друг друга на доступность по heartbeat. В случае обнаружения недоступности master узла инициализируют выбор нового и проводят failover. Узлы-реплики могут использоваться для чтения.
Пример: MongoDB (replica set), Redis, MSSQL, MySQL, PostgreSQL, RabbitMQ, Kafka (но есть нюансы).</p>
</div>
<div class="sect3">
<h4 id="_2n_избыточность_2n_redundancy">2N избыточность (2N Redundancy)</h4>
<div class="paragraph">
<p>Схема, напоминающая Hot Standby. Все избыточные юниты проверяют доступность друг друга. При обнаружении, что активный (эксплуатируемый) юнит недоступен, инициализируются аварийное переключение (failover). Ранее была распространена в телекоме, как схема увеличения надёжности через использование аналогичного железа, но различного ПО, выполняющего аналогичные функции, чтобы избежать отказа всех узлов в критически важной системе с одной и той же ошибкой в ПО. Сейчас подобная схема используется преимущественно в инфраструктуре датацентров для управление питанием.</p>
</div>
</div>
<div class="sect3">
<h4 id="_Трёх_компонентное_большинство_с_голосованием_triplex_duplex">Трёх-компонентное большинство с голосованием (Triplex-Duplex)</h4>
<div class="paragraph">
<p>В эксплуатации находятся три компонента, вывод от всех трёх компонентов сравнивается между собой, если один из компонентов выдаёт отличное от большинства значение, то он больше не может рассматриваться как достоверный и выводится из эксплуатации. Компоненты не подлежат ремонту во время эксплуатации, только замена. Схема используется в критически важных системах: авионика, медицинские системы, системы жизнеобеспечения, индустриальные системы повышенной надёжности.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_Аварийное_переключение_failover_стратегии_и_практики">Аварийное переключение (failover), стратегии и практики</h3>
<div class="paragraph">
<p>Для аппаратных компонентов failover обрабатывается в драйверах системы, которые предоставляет вендор вместе с железом. Нормальная обработка такого failover не вызывает прекращение работы оборудования и не вызывает перезагрузку ОС.</p>
</div>
<div class="paragraph">
<p>Если сбой происходит в кластере, миграция между сервисами внутри него должна удовлетворять следующим критериям:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Прозрачность.</strong> Аварийное переключение после восстановления не должно мешать работе клиентов. Так сбой у master/active узла в HA кластере должен повлечь переброс трафика на резервный standby узел (который становится active) и установления соединений от клиентов к этому серверу, после чего возобновляется их нормальная работа. Опционально возможно выполнение повторных процедур аутентификации.</p>
</li>
<li>
<p><strong>Время переключения.</strong> В идеале не должно приводить к длительной остановке зависимого клиента. Так например в HA <code>replica set</code> кластерах c небольшим количеством узлов, secondary узлы через определенные промежутки времени опрашивают primary, если он недоступен, то выбирают (election) новый primary узел, который принимает на себя клиентов или управляет взаимодействием с ними. Период времени (heartbeat rate) между опросами обычно настраиваемый и не больше двух минут. Таким образом, клиент, потеряв соединение с primary (по его таймауту), пытается соединиться с каким-нибудь другим узлом из кластера, который можно было бы идентифицировать как новый primary. В этом случае, согласованно и рационально настроенные таймаут соединения, hearbeat rate и на клиенте имеются retry политики и backpessure подход (о них позже), то переключение на новый primary сервер должно занять максимум несколько минут и не привести к потере данных для клиента.</p>
</li>
<li>
<p><strong>Автоматизация.</strong> Переключение на избыточный узел желательно осуществлять в автоматическом режиме, чтобы способствовать уменьшению MTTR. Если внутри кластера сервера имеют разные статусы, то механизм выбора главного сервера также должен запускаться автоматически.</p>
</li>
<li>
<p><strong>Гарантированный доступ к предоставляемому сервису.</strong> После аварийного переключения клиент должен иметь доступ к тем же самым данным (но есть нюансы в виде консистентности данных на различных узлах) и тем же самым сервисам, которые предоставлялись прошлым сервером в этом кластере.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_Управление_отказами">Управление отказами</h3>
<div class="paragraph">
<p>Таймлайны отказов рассматривали ранее, сейчас вкратце:
Вкратце:
<span class="image"><img src="./images/fault_management.jpg" alt="242" width="540" height="Fault management"></span></p>
</div>
<div class="paragraph">
<p>Современные Agile подходы с короткими циклами релизов, CI/CD практики и прочий Ops-инструментарий очень сильно упростили работу с отказами, позволяя эксплуатировать большие системы существенно меньшим количеством людей.</p>
</div>
<div class="paragraph">
<p>Чек-лист того, чтобы упросить детекцию, диагностику отказов, а также оценку эффекта от их возникновения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>healt-check сервисов</p>
</li>
<li>
<p>сбор логов</p>
</li>
<li>
<p>сбор метрик</p>
</li>
<li>
<p>определение пороговых значений (thresholds) для выше обозначенных метрик</p>
</li>
<li>
<p>оповещения для администраторов, сотрудников поддержки занятых в эксплуатации, инцидент- трекинг сервис (PageDuty, VictorOps)</p>
</li>
<li>
<p>использование фреймворков для трейсинга</p>
</li>
<li>
<p>автоматизация обработки отказов</p>
</li>
<li>
<p>организация дежурств, уровней саппорта, политик экскалаций</p>
</li>
<li>
<p>журнал postmortem с отчётами о развитии крупных отказов, описание поиска решения, что сделано, чтобы предотвратить в будущем. Не забывать им делиться с другими командами.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sla_slo_sli">SLA, SLO, SLI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Есть несколько подходов по работе с документами связанными с доступностью системы. Различия в них не концептуальные, но связанные с бизнес-моделью организации и внутренними процессами.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Service Level Agreement (SLA)
</td>
<td class="hdlist2">
<p>договоренность об уровне сервиса</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Service Level Objectives (SLO)
</td>
<td class="hdlist2">
<p>цели по предоставлению уровня сервиса (внутренние требования (документы)), является более строгим набором требований чем SLA, так как нарушение последнего может привести к явным финансовым и репетиционным потерям.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Service Level Indicators (SLI)
</td>
<td class="hdlist2">
<p>метрики доступности системы</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>SLA</strong> - соглашение между лицом, сервис представляющим и лицом, являющимся его клиентом. Может быть оформлено в виде документа, где явно прописаны обязанности первого лица, условия, исключения если такие есть. Чаще всего там прописывается: процент доступности, MTTR, график обслуживания когда сервис может быть недоступен либо функционировать в ограниченном режиме, производительность сервиса, размеры штрафа в случае несоблюдения указанных ранее характеристик и свойств. Рекомендуется в SLA указывать те характеристики сервиса, которые влияют непосредственно на выручку, то есть фокусироваться на наиболее приоритетных и для клиентов, и для инженеров.</p>
</div>
<div class="paragraph">
<p><strong>SLO</strong> - внутренний документ, описывающий цели по доступности. В нём содержатся те же самые характеристики и свойства системы, что и в SLA, но с более строгими значениями, что бы иметь запас по надёжности между целью и договорённостями с клиентами. Источник информации по пороговым значениями (thresholds) для систем мониторинга и оповещения.</p>
</div>
<div class="paragraph">
<p><strong>SLI</strong> - текущие измеряемые показатели сервиса. Там могут быть типичные RPS, QPS, latency, пропускная способность, так и собственные замеры доступности. Между различными внутренними сервисами, плюс с внешних для системы узлов.</p>
</div>
<div class="paragraph">
<p>Эти три документа позволяют не теряться в соглашениях, целях и текущих значениях. Люди, ответственные за коммуникации с клиентами точно знают, что предоставляют. Инженеры поддерживают и проектируют решения с четко обозначенными ограничениями. Более подробно с темой SLA, SLO, SLI можно ознакомиться в книге "Site Reliability Engineering" (2016) <a href="#sre">[sre]</a>, написанной инженерами Google.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Организационные_подходы_для_построения_систем_высокой_доступности">Организационные подходы для построения систем высокой доступности</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если желаете увеличить доступность системы для внешних пользователей, всегда начинайте анализ с самого верхнего уровня, чтобы не оказаться в ситуации, когда балансировщик трафика с отказоустойчивым кластером стоит за каким-то жалким единственным роутером, который работает лишь по стечению случайностей. Эту проблему всегда необходимо рассматривать именно со стороны пользователя системы или сервиса, который к ней обращается, а не изнутри.</p>
</div>
<div class="sect2">
<h3 id="_Не_экономить_на_самом_дешевом_железе">Не экономить на самом дешевом железе</h3>
<div class="paragraph">
<p>Выбирать железо стоит исходя не только из его минимальной цены за определенные возможности, а по результатам расчёта ROI, где учитывается его непосредственная цена, его время эксплуатации в системе, наличие специалистов для его обслуживания, гарантийного сервиса и близость поставщиков для его замены по гарантии или для обновления.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Согласованность">Согласованность</h3>
<div class="paragraph">
<p>Компоненты системы должны быть согласованы между собой, например:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Емкость канала должна быть расчётной для узла который на ней висит.</p>
</li>
<li>
<p>Рабочие инстансы должны иметь столько RAM, которая бы соответствовала работающему там приложению с учётом им потребляемой памяти (в т.ч. установленным лимитам).</p>
</li>
<li>
<p>Сервера должны иметь такую ёмкость локального диска для объема операций записи за период, после чего будут действовать механизмы retention во избежание отказов от появления ошибок.</p>
</li>
<li>
<p>Приложения должны использовать хранилища с учётом их особенностей и ограничений, например: максимальный размер базы, количество столбцов, максимальный размер записи.</p>
</li>
<li>
<p>Клиенты и серверы должны использовать одни и те же версии протоколов и соответствовать друг другу по API.</p>
</li>
<li>
<p>Надёжность отдельных компонентов тоже должна быть обоснована и согласована между собой.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>График обслуживания должен быть согласован с временем, когда на систему минимальная нагрузка, либо позволяет SLA. Если это промежуточная система для её клиента, то зависимая система должна учитывать SLA системы от которой зависит и в случае потребности иметь некоторую изоляцию от последней, чтобы предоставить сервис если это возможно, или хотя бы корректно отработать отказ.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Ответственность">Ответственность</h3>
<div class="paragraph">
<p>Ни вендор, ни поставщик программного обеспечения, ни программисты не могут построить высокодоступную и комфортную для пользователя системы. Построение такой системы - это тестирование, интеграция, испытания, верификация приложений и рабочих процессов. Наивно полагать, что развернув определенное ПО на рабочем контуре, вы получите высокодоступную систему, так как это: максимальный MTBF и минимальный MTTR, которые доводятся до нужных значений именно отладкой рабочих процессов сотрудников. Не стоит уповать и на организацию кластеров и средства репликации данных. Без своевременных вмешательств и организации работ по выводу из состоянии деградации система не может быть отказоустойчивой и высокодоступной. Формируйте SLA, SLO, ведите SLI.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Устранение_единых_точек_отказа_single_point_of_failure_spof">Устранение единых точек отказа (Single Point of Failure (SPOF))</h3>
<div class="paragraph">
<p>Анализируйте систему на присутствие в ней элементов, выход из стоя которых может привести к невозможности продолжить исполнение даже в ограниченном режиме. Проще всего начать с анализа цепочек исполнения, зависимостей или data-flow диаграмм. Достаточно пройтись по ключевым обслуживаемым процессам, чтобы уже появилось представление о самых слабых узлах в цепочке. Но далеко не каждый компонент, представляющий собой SPOF, возможно дублировать или устранить иногда по финансовым причинам (слишком дорогое дублирующее железо), ограничения физические (например только один вводной канал) или концептуальное ограничение (например CAP-теорема<a href="#cap">[cap]</a>)</p>
</div>
</div>
<div class="sect2">
<h3 id="_Консолидация_серверов">Консолидация серверов</h3>
<div class="paragraph">
<p>Вместо использования множества мелких серверов, иногда имеет смысл использовать лишь несколько, но гораздо более мощных для того, чтобы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>упростить топологию и уменьшить количество узлов</p>
</li>
<li>
<p>сократить затраты на обслуживание (обновление, резервное копирование и т.п.)</p>
</li>
<li>
<p>улучшить производительность из-за уменьшения затрат на передачу данных по сети</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Инструментарий для виртуализации и оркестрацией серверов упрощает управление распределенной инфраструктурой, еще и с прослойкой абстракции над железом, но для части задач (такие как базы данных) или большие legacy системы, всё ещё имеет смысл.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Автоматизация_и_оптимизиация">Автоматизация и оптимизиация</h3>
<div class="paragraph">
<p>Чем выше уровень автоматизации - тем меньше требуется время на операции, меньше ответственных за них. Ускорение и автоматизация цикла "сборка-тестирование" добавляет удобства для инженеров, увеличивает количество таких циклов за единицу времени, время тратится более эффективно. СI/CD подходы сильно упрощают раскатывание новых релизов по контурам, тем самым уменьшая и MTTR, и time to market (TTM).</p>
</div>
</div>
<div class="sect2">
<h3 id="_Типовые_конфигурации_и_общие_репозитории">Типовые конфигурации и общие репозитории</h3>
<div class="paragraph">
<p>Унификация сильно помогает для уменьшения времени на проектирование, тестирование и развертывание новых сервисов. Общие конфигурации и артефакты сильно помогают в этом на всех стадиях от идентификации потребности, до развертывания в production.
Чек-лист:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>список рекомендованного ПО для production</p>
</li>
<li>
<p>репозиторий скриптов развертывания инфраструктуры - Infrastructure as Code</p>
</li>
<li>
<p>репозиторий артефактов (Artifactory, Bintray, GitLab)</p>
</li>
<li>
<p>реестр типовых образов (Docker Registry, Amazon ECR, GitLab Container Registry)</p>
</li>
<li>
<p>типовые шаблоны для security groups</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_Мониторинг_и_оповещение">Мониторинг и оповещение</h3>
<div class="paragraph">
<p>Без мониторинга невозможно разобраться в каком состоянии находится система. Каждое запущенное приложение представляет без сбора метрик, health-checks и логов представляет собой чёрный ящик: что-то подаётся на вход, что-то поступает на выход с не всегда очевидными side-effects. Чтобы это избежать используют health-check интерфейсы и сбор метрик.<br>
Через Health-check интерфейс проверяют живо ли приложение, вместе с пустым ответом приложение может предоставлять ещё и некоторую информацию о своём состоянии. В зависимости от подходов и вариантов процедуры развертывания организуют и автоматические операции, там может быть: перезапуск, оповещение оператора, добавление информации об этом в журнал.<br>
Метрики -  одномоментные показатели состояния ПО и железа, могут быть в виде счётчиков, таймеров, гистограм и т.п. Все они помогают понять в каком состоянии система была, находится и какова динамика изменений. Кроме системных метрик (RPS, QPS, latency, заполненность очередни и т.п.) могут собираться и бизнесовые метрики с информацией из предметной области бизнеса.</p>
</div>
<div class="paragraph">
<p>Собрать метрики мало - нужно ещё ими воспользоваться, в этом помогают различные инструменты их отображения: Kibana, Grafana, Prometheus, Datadog. Быстрый и удобный UI с дашбордами для просмотра информации о метриках - хорошая инвестиция в комфорт работы и уменьшение MTTR.</p>
</div>
<div class="paragraph">
<p>На основе используемых метрик, их граничных значений, алгоритмов определения аномалий, а также появления определенных записей в логах, выстраивается система оповещения о внештатных ситуациях и инцидентах. Слишком строгие настройки могут вызвать ложные оповещения чем будут раздражать операторов, инженеров и портить отчётность. Слишком высокий порог может не показать деградацию системы, что тоже не хорошо. Следует искать приемлемый баланс, следуя рекомендациям вендоров, поставщикам ПО, а также используя инженерные оценки.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Измерение_производительности">Измерение производительности</h3>
<div class="paragraph">
<p>Рассуждая о доступности какого-то сервиса для клиента, мы имеем ввиду, что <strong>все</strong> компоненты в цепочке исполнения должны иметь время реакции из конкретного временного интервала, иначе уровень сервиса для клиента может упасть до неприемлемо низких значений. Чтобы не столкнуться с непредвиденной деградацией производительности в поддержании высокодоступной системы должны быть использованы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#wiki_bm">бенчмаркинг</a> отдельных компонентов системы</p>
</li>
<li>
<p>нагрузочное или стресс тестирование - подача нагрузки на систему или её изолированную часть и замеры, чтобы определить граничные возможности системы обработать выданную нагрузку. Качество проводимого тестирования сильно зависит от возможности эмулировать паттерн нагрузки как и на боевой системе, организации замеров.</p>
</li>
<li>
<p>сбор и анализ метрик производительности во время эксплуатации, могут быть как системные метрики, так и из предметной области.</p>
</li>
<li>
<p>stability testing - продолжительное по времени тестирование, проводимое с симуляцией различных условий эксплуатации.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Результаты тестирования сохраняются с указанием версии ПО или железа, чтобы в будущем иметь возможности системы от релиза к релизу. Помогает выявить внесённые изменения, повлекшие к деградации производительности.</p>
</div>
<div class="paragraph">
<p>Последовательные и систематичные меры дадут возможность не только видеть состояние системы под нагрузкой, понимать границы той самой доступности предоставляемого сервиса, но и видеть причинно-следственные связи от изменений в самой системе или её реакцию на изменение нагрузки. Чем больше будет похожа тестовая нагрузка на нагрузку во время эксплуатации, тем ближе будет соответствие результатам в эксплуатации. Кроме того, обладая данными о фактической производительности компонентов, появляется возможность более точно рассчитать потребности в ресурсах при горизонтальном масштабировании.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Обучение_и_тренинги_персонала">Обучение и тренинги персонала</h3>
<div class="paragraph">
<p>Обучайте людей пользоваться инструментами, рассказывайте об их возможностях влиять на систему, какова их роль в процессе и за что они отвечают. Занятый в эксплуатации человек будет действовать более уверенно и быстро, когда он знает о своих возможностях.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Раздельные_контуры">Раздельные контуры</h3>
<div class="paragraph">
<p>Чтобы процессы разработки и тестирования не влияли на саму эксплуатируемую систему, необходимо разделять среды с различной их целью. Обычно используются следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>sandbox для разработчиков где тестируется новый софт, технологии, железо</p>
</li>
<li>
<p>dev контур для работы над кодом, dev-тестирования, если невозможно развернуть систему для теста на локальном компьютере инженера, в следствии этого должен относительно хорошо поддерживаться, чтобы не замедлять работу инженеров</p>
</li>
<li>
<p>QA контур, может быть несколько, для ручного тестирования, регрессионного, интеграционного, конфигурация ещё ближе к production. Может иметь реплицированные или восстановленные из резервных копий данные с production.</p>
</li>
<li>
<p>Staging - практически повторяет по топологии production и его возможности. Все изменения тестируются перед тем, как попасть в эксплуатационный контур. Мониторинг, сбор логов и метрик практически всегда обязателен тут. Играет важную роль для эмуляции случаев произошедших в эксплуатации и проверке гипотез.</p>
</li>
<li>
<p>Producton - он же эксплуатационный контур. Контуров может быть несколько для создания избыточности, если она требуется, раскатывают обновления в таком случае последовательно, чтобы иметь возможность быстро переключиться на резервный. Либо избыточный контур находится в другом дата-центре, чтобы иметь возможность обработать отказ всего ДЦ.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Заключение">Заключение</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Рассмотрели, пусть и крайне поверхностно, но практически все (я надеюсь) концепции и общие подходы построения высокодоступных систем. Как выше уже определили, надёжность - это максимальное время работы между сбоями и минимальное время восстановления. За всем этим скрывается:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Надёжность компонентов (будет в следующей статье из серии)</p>
</li>
<li>
<p>Работа с концептуальными ограничениями в распределённых вычислениях.</p>
</li>
<li>
<p>Избыточность компонентов, чтобы иметь устойчивость к сбоям эксплуатируемых узлов.</p>
</li>
<li>
<p>Прозрачный или хотя бы быстрый процесс аварийного переключения.</p>
</li>
<li>
<p>Максимально быстрый процесс от идентификации сбоя, до его решения.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Что ещё рекомендуется изучить по данной теме:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Большая часть тем гораздо глубже описана в книге "Site Reliability Engineering"<a href="#sre">[sre]</a></p>
</li>
<li>
<p>По эксплуатации и дизайну приложений в AWS рекомендую "AWS Well-Architected Framework"<a href="#aws-waf">[aws-waf]</a></p>
</li>
<li>
<p>Отличная книга "Distributed Systems. Concurrency and Consistency (Matthieu Perrin, 2017)" <a href="#ds1e">[ds1e]</a>, которая поможет при выборе инструментария, независимо on-premise, cloud или собственного решения. Отличный гайд по "нюансам" и подводным камням, которые иногда не заметны под маркетинговыми лозунгами.</p>
</li>
<li>
<p>Знакомство с основами распределенных алгоритмов, границами их применимости, рекомендую начать с Distributed Systems. An Algorithmic Approach (2013). В книге рассказывается о таких важных алгоритмах, как: выбор мастера в кластера, основах трейсинга с использованием алгоритмов обхода дерева, скедулинга задач среди воркеров.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Ссылки">Ссылки</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="std610"></a>[std610]  <a href="https://pdfs.semanticscholar.org/dce9/9209120ebed7f5d68e3644fdcd160d4c366c.pdf">IEEE Standard Glossary of Software Engineering Terminology</a></p>
</li>
<li>
<p><a id="hadr"></a>[hadr] High Availability and Disaster Recovery: Concepts, Design, Implementation, (Klaus Schmidt, 2006)</p>
</li>
<li>
<p><a id="cap"></a>[cap] <a href="https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e">CAP Theorem and Distributed Database Management Systems (Syed Sadat Nazrul, 2018)</a></p>
</li>
<li>
<p><a id="wiki_bm"></a>[wiki_bm] <a href="https://en.wikipedia.org/wiki/Benchmark_(computing)">wiki: Benchmark (computing)</a></p>
</li>
<li>
<p><a id="wiki_raid"></a>[wiki_raid] <a href="https://en.wikipedia.org/wiki/RAID">wiki:RAID</a></p>
</li>
<li>
<p><a id="hat"></a>[hat] <a href="https://arxiv.org/abs/1302.0309v2">Highly Available Transactions: Virtues and Limitations
(Extended Version) (Peter Bailis, Aaron Davidson, Alan Fekete, Ali Ghodsi, Joseph M. Hellerstein, Ion Stoica, 2013)</a></p>
</li>
<li>
<p><a id="ds1e"></a>[ds1e] <a href="https://www.elsevier.com/books/distributed-systems/perrin/978-1-78548-226-7">Distributed Systems. Concurrency and Consistency (Matthieu Perrin, 2017)</a></p>
</li>
<li>
<p><a id="pgsql-tr"></a>[pgsql-tr] <a href="https://www.postgresql.org/docs/11/transaction-iso.html">PostgeSQL Documentation. Transaction Isolation</a></p>
</li>
<li>
<p><a id="mssql-si"></a>[mssql-si] <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server">Snapshot Isolation in SQL Server</a></p>
</li>
<li>
<p><a id="oracle-si"></a>[oracle-si] <a href="https://docs.oracle.com/cd/E17276_01/html/gsg_xml_txn/cxx/isolation.html#snapshot_isolation">Oracle DB. Isolation</a></p>
</li>
<li>
<p><a id="abadi"></a>[abadi] <a href="http://cs-www.cs.yale.edu/homes/dna/papers/abadi-pacelc.pdf">Consistency Tradeoffs in Modern Distributed Database System Design (Yale Univercity, 2012)</a></p>
</li>
<li>
<p><a id="sre"></a>[sre] Site Reliability Engineering (Betsy Beyer, Chris Jones,
Jennifer Petoff &amp; Niall Richard Murphy), 2016</p>
</li>
<li>
<p><a id="aws-waf"></a>[aws-waf] <a href="https://d1.awsstatic.com/whitepapers/architecture/AWS_Well-Architected_Framework.pdf">AWS Well-Architected Framework</a></p>
</li>
</ul>
</div>
</div>
</div>

    </div>

    





<div class="article-tags">
  
  <a class="badge badge-light" href="/tags/high-availablitiy/">high-availablitiy</a>
  
  <a class="badge badge-light" href="/tags/distributed-systems/">distributed-systems</a>
  
  <a class="badge badge-light" href="/tags/ha/">HA</a>
  
</div>



<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=/post/2019/03-distsys/&amp;text=%d0%92%d1%8b%d1%81%d0%be%d0%ba%d0%b0%d1%8f%20%d0%b4%d0%be%d1%81%d1%82%d1%83%d0%bf%d0%bd%d0%be%d1%81%d1%82%d1%8c:%20%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%86%d0%b8%d0%b8,%20%d0%be%d0%b1%d1%89%d0%b8%d0%b5%20%d0%bf%d1%80%d0%b0%d0%ba%d1%82%d0%b8%d0%ba%d0%b8%20%d0%bf%d0%be%d1%81%d1%82%d1%80%d0%be%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b8%20%d1%81%d0%be%d0%bf%d1%80%d0%be%d0%b2%d0%be%d0%b6%d0%b4%d0%b5%d0%bd%d0%b8%d1%8f" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=/post/2019/03-distsys/&amp;t=%d0%92%d1%8b%d1%81%d0%be%d0%ba%d0%b0%d1%8f%20%d0%b4%d0%be%d1%81%d1%82%d1%83%d0%bf%d0%bd%d0%be%d1%81%d1%82%d1%8c:%20%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%86%d0%b8%d0%b8,%20%d0%be%d0%b1%d1%89%d0%b8%d0%b5%20%d0%bf%d1%80%d0%b0%d0%ba%d1%82%d0%b8%d0%ba%d0%b8%20%d0%bf%d0%be%d1%81%d1%82%d1%80%d0%be%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b8%20%d1%81%d0%be%d0%bf%d1%80%d0%be%d0%b2%d0%be%d0%b6%d0%b4%d0%b5%d0%bd%d0%b8%d1%8f" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=%d0%92%d1%8b%d1%81%d0%be%d0%ba%d0%b0%d1%8f%20%d0%b4%d0%be%d1%81%d1%82%d1%83%d0%bf%d0%bd%d0%be%d1%81%d1%82%d1%8c:%20%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%86%d0%b8%d0%b8,%20%d0%be%d0%b1%d1%89%d0%b8%d0%b5%20%d0%bf%d1%80%d0%b0%d0%ba%d1%82%d0%b8%d0%ba%d0%b8%20%d0%bf%d0%be%d1%81%d1%82%d1%80%d0%be%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b8%20%d1%81%d0%be%d0%bf%d1%80%d0%be%d0%b2%d0%be%d0%b6%d0%b4%d0%b5%d0%bd%d0%b8%d1%8f&amp;body=/post/2019/03-distsys/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=/post/2019/03-distsys/&amp;title=%d0%92%d1%8b%d1%81%d0%be%d0%ba%d0%b0%d1%8f%20%d0%b4%d0%be%d1%81%d1%82%d1%83%d0%bf%d0%bd%d0%be%d1%81%d1%82%d1%8c:%20%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%86%d0%b8%d0%b8,%20%d0%be%d0%b1%d1%89%d0%b8%d0%b5%20%d0%bf%d1%80%d0%b0%d0%ba%d1%82%d0%b8%d0%ba%d0%b8%20%d0%bf%d0%be%d1%81%d1%82%d1%80%d0%be%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b8%20%d1%81%d0%be%d0%bf%d1%80%d0%be%d0%b2%d0%be%d0%b6%d0%b4%d0%b5%d0%bd%d0%b8%d1%8f" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://web.whatsapp.com/send?text=%d0%92%d1%8b%d1%81%d0%be%d0%ba%d0%b0%d1%8f%20%d0%b4%d0%be%d1%81%d1%82%d1%83%d0%bf%d0%bd%d0%be%d1%81%d1%82%d1%8c:%20%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%86%d0%b8%d0%b8,%20%d0%be%d0%b1%d1%89%d0%b8%d0%b5%20%d0%bf%d1%80%d0%b0%d0%ba%d1%82%d0%b8%d0%ba%d0%b8%20%d0%bf%d0%be%d1%81%d1%82%d1%80%d0%be%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b8%20%d1%81%d0%be%d0%bf%d1%80%d0%be%d0%b2%d0%be%d0%b6%d0%b4%d0%b5%d0%bd%d0%b8%d1%8f%20/post/2019/03-distsys/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
  </ul>
</div>












  






  
  
  
    
  
  
  <div class="media author-card content-widget-hr">
    
      
      <img class="portrait mr-3" src="/authors/salimonov/avatar_salimonov_small_hu469099bcddfca1270d43d68bcc28120c_29069_250x250_fill_q90_lanczos_center.jpeg" alt="Avatar">
    

    <div class="media-body">
      <h5 class="card-title"><a href="/">Alexander Salimonov</a></h5>
      <h6 class="card-subtitle">Engineering Manager</h6>
      <p class="card-text">Distributed and data-intensive sytems, databases, data processing, cloud computing.</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="/#contact" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://twitter.com/asalimonov" target="_blank" rel="noopener">
        <i class="fab fa-twitter"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/asalimonov" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
    
    
    
    
    
    
    
      
    
    <li>
      <a href="/files/Alexander_Salimonov_CV.pdf" >
        <i class="ai ai-cv"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>









  
  
  <div class="article-widget content-widget-hr">
    <h3>Related</h3>
    <ul>
      
      <li><a href="/post/2019/02-distsys/">Сбои и восстановление работоспобности систем</a></li>
      
      <li><a href="/post/2019/01-distsys/">Системы с высокой доступностью</a></li>
      
    </ul>
  </div>
  



  </div>
</article>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>


      

    
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js" integrity="sha256-1zu+3BnLYV9LdiY85uXMzii3bdrkelyp37e0ZyTAQh0=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/python.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/sql.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/json.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/yaml.min.js"></script>
        
      

      
      
    

    
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.3227ab49eed49815d1b4ba40154f74e7.js"></script>

    






  
  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    Alexander Salimonov · ©  2019 &middot; 

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
